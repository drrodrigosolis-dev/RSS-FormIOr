<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.9">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<h1 id="chp:page-2-core-concepts-and-data-shapes">Page 2: Core Concepts and Data Shapes</h1>
<p><a href="../index.html">Home</a> | <a href="01-why-formior.html">Prev: Why FormIOr Exists</a> | <a href="03-getting-started.html">Next: Getting Started</a></p>
<p>FormIOr works with two main data shapes:</p>
<ol>
<li>A plain data frame (a regular R table)</li>
<li>A “flat” object returned by <code>FlattenSubmissions()</code></li>
</ol>
<p>The flat object is a list that contains:</p>
<ul>
<li><code>FlatResponses</code>: the actual data frame</li>
<li><code>ColumnNames</code>: a simple index of column names</li>
</ul>
<p>Most functions accept either a data frame or a flat object. If you pass a flat
object, FormIOr automatically uses <code>flat$FlatResponses</code> as the working table.</p>
<h3 id="sec:why-flattening-matters">Why flattening matters</h3>
<p>FormIO exports often include nested lists (for example, repeating sections or
edit grids). Flattening expands these nested structures into columns and rows so
that the data can be analyzed or exported without special tooling.</p>
<p>Flattening can create multiple rows per submission. This is not an error. It is
how repeated answers are represented. FormIOr provides multiple ways to reduce
those repeated answers down to one row per submission:</p>
<ul>
<li><code>ResolveRepeats()</code> for automatic collapsing</li>
<li><code>FixDups()</code> for interactive, column-by-column decisions</li>
<li><code>DeduplicateSubmissions()</code> when duplicates are true duplicates</li>
</ul>
<h3 id="sec:the-submission-id-column">The submission ID column</h3>
<p>Many cleaning steps require a submission ID column (<code>id_col</code>). This is used to
group repeated rows that belong to the same submission. If you do not know which
column is the submission ID, the wizard will suggest one, or you can inspect
column names manually.</p>
<hr />
<p>Navigation</p>
<ul>
<li>Prev: <a href="01-why-formior.html">Why FormIOr Exists</a></li>
<li>Next: <a href="03-getting-started.html">Getting Started in R</a></li>
<li>Home: <a href="../index.html">Handbook Index</a></li>
</ul>
</div>
</body>
</html>
